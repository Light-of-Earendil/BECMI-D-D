<?php
/**
 * BECMI D&D Character Manager - Save Hex Map Endpoint
 * 
 * Saves both map metadata and all tiles in a single request.
 * This avoids session issues that occur when making multiple sequential requests.
 * 
 * **Request:** POST
 * 
 * **Body Parameters:**
 * - `map_id` (int, required) - Map ID to save
 * - `map_name` (string, optional) - Map name (3-100 characters)
 * - `map_description` (string, optional) - Map description
 * - `width_hexes` (int, optional) - Map width in hexes (1-200)
 * - `height_hexes` (int, optional) - Map height in hexes (1-200)
 * - `hex_size_pixels` (int, optional) - Hex size in pixels (10-200)
 * - `tiles` (array, optional) - Array of tile objects to save
 * - `deleted_tiles` (array, optional) - Array of {q, r} objects for tiles to delete
 * 
 * **Response:**
 * ```json
 * {
 *   "status": "success",
 *   "message": "Map saved successfully",
 *   "data": {
 *     "map": {...},
 *     "tiles_saved": int,
 *     "tiles_created": int,
 *     "tiles_updated": int,
 *     "tiles_deleted": int
 *   }
 * }
 * ```
 * 
 * **Permissions:**
 * - Map creator: Can save map
 * - Session DM: Can save map
 * - Others: 403 Forbidden
 * 
 * **Called From:**
 * - `HexMapEditorModule.saveMap()` - Saves entire map in one request
 * 
 * @package api/hex-maps
 * @api POST /api/hex-maps/save.php
 * @since 1.0.0
 */

// Start output buffering BEFORE any includes to catch any output
if (!ob_get_level()) {
    ob_start();
}

require_once '../../app/core/database.php';
require_once '../../app/core/security.php';

// Clear any output that might have been generated by includes
if (ob_get_level() && ob_get_length() > 0) {
    ob_clean();
}

// Initialize security
Security::init();

// Set content type
header('Content-Type: application/json');

try {
    // Only allow POST requests
    if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
        Security::sendErrorResponse('Method not allowed', 405);
    }
    
    // Get JSON input FIRST (before auth check)
    $input = Security::validateJSONInput();
    
    // Validate required fields
    $mapId = isset($input['map_id']) ? (int) $input['map_id'] : 0;
    
    if ($mapId <= 0) {
        Security::sendValidationErrorResponse(['map_id' => 'Valid map ID is required']);
    }
    
    // Get user ID - try session first, fallback to request if session fails
    $userId = null;
    
    // Try to get from session
    if (Security::isAuthenticated()) {
        $userId = Security::getCurrentUserId();
    }
    
    // If session failed, try to get from request
    if (!$userId || $userId <= 0) {
        if (isset($input['user_id']) && is_numeric($input['user_id'])) {
            $userId = (int) $input['user_id'];
            
            // Validate user exists in database
            $db = getDB();
            $user = $db->selectOne("SELECT user_id FROM users WHERE user_id = ?", [$userId]);
            if (!$user) {
                Security::sendErrorResponse('Invalid user ID', 401);
            }
        } else {
            Security::sendErrorResponse('Authentication required', 401);
        }
    }
    
    // Check CSRF token (only if session works)
    if (Security::isAuthenticated() && !Security::checkCSRFToken()) {
        Security::sendErrorResponse('Invalid CSRF token', 403);
    }
    
    // Get database connection (if not already got)
    if (!isset($db)) {
        $db = getDB();
    }
    
    // Get map and verify permissions
    $map = $db->selectOne(
        "SELECT hm.map_id, hm.created_by_user_id, hm.session_id, gs.dm_user_id as session_dm_user_id
         FROM hex_maps hm
         LEFT JOIN game_sessions gs ON hm.session_id = gs.session_id
         WHERE hm.map_id = ?",
        [$mapId]
    );
    
    if (!$map) {
        Security::sendErrorResponse('Hex map not found', 404);
    }
    
    // Check permissions: creator or session DM can save
    $canSave = false;
    if ($map['created_by_user_id'] == $userId) {
        $canSave = true;
    } elseif ($map['session_id'] && $map['session_dm_user_id'] == $userId) {
        $canSave = true;
    }
    
    if (!$canSave) {
        Security::sendErrorResponse('You do not have permission to save this hex map', 403);
    }
    
    // Begin transaction for atomic save
    $db->beginTransaction();
    
    try {
        $tilesCreated = 0;
        $tilesUpdated = 0;
        $tilesDeleted = 0;
        
        // Update map metadata if provided
        if (isset($input['map_name']) || isset($input['map_description']) || 
            isset($input['width_hexes']) || isset($input['height_hexes']) || 
            isset($input['hex_size_pixels']) || isset($input['scale'])) {
            
            $updateFields = [];
            $updateParams = [];
            
            if (isset($input['map_name'])) {
                $mapName = Security::sanitizeInput($input['map_name']);
                if (strlen($mapName) < 3 || strlen($mapName) > 100) {
                    throw new Exception('Map name must be between 3 and 100 characters');
                }
                $updateFields[] = "map_name = ?";
                $updateParams[] = $mapName;
            }
            
            if (isset($input['map_description'])) {
                $updateFields[] = "map_description = ?";
                $updateParams[] = Security::sanitizeInput($input['map_description']) ?: null;
            }
            
            if (isset($input['width_hexes'])) {
                $widthHexes = (int) $input['width_hexes'];
                if ($widthHexes < 1 || $widthHexes > 200) {
                    throw new Exception('Width must be between 1 and 200 hexes');
                }
                $updateFields[] = "width_hexes = ?";
                $updateParams[] = $widthHexes;
            }
            
            if (isset($input['height_hexes'])) {
                $heightHexes = (int) $input['height_hexes'];
                if ($heightHexes < 1 || $heightHexes > 200) {
                    throw new Exception('Height must be between 1 and 200 hexes');
                }
                $updateFields[] = "height_hexes = ?";
                $updateParams[] = $heightHexes;
            }
            
            if (isset($input['hex_size_pixels'])) {
                $hexSizePixels = (int) $input['hex_size_pixels'];
                if ($hexSizePixels < 10 || $hexSizePixels > 200) {
                    throw new Exception('Hex size must be between 10 and 200 pixels');
                }
                $updateFields[] = "hex_size_pixels = ?";
                $updateParams[] = $hexSizePixels;
            }
            
            // Handle scale - distance in miles from center of one hex to center of the next
            if (isset($input['scale'])) {
                if ($input['scale'] === null || $input['scale'] === '') {
                    // Allow null/empty to clear scale
                    try {
                        $updateFields[] = "scale = ?";
                        $updateParams[] = null;
                    } catch (Exception $e) {
                        // If scale column doesn't exist yet, ignore
                        if (strpos($e->getMessage(), 'scale') === false && strpos($e->getMessage(), 'Unknown column') === false) {
                            throw $e;
                        }
                    }
                } else {
                    $scale = filter_var($input['scale'], FILTER_VALIDATE_FLOAT);
                    if ($scale === false || $scale < 0) {
                        throw new Exception('Scale must be a positive number (miles)');
                    }
                    try {
                        $updateFields[] = "scale = ?";
                        $updateParams[] = $scale;
                    } catch (Exception $e) {
                        // If scale column doesn't exist yet, ignore
                        if (strpos($e->getMessage(), 'scale') === false && strpos($e->getMessage(), 'Unknown column') === false) {
                            throw $e;
                        }
                    }
                }
            }
            
            if (!empty($updateFields)) {
                $updateFields[] = "updated_at = NOW()";
                $updateParams[] = $mapId;
                
                $sql = "UPDATE hex_maps SET " . implode(", ", $updateFields) . " WHERE map_id = ?";
                $db->update($sql, $updateParams);
            }
        }
        
        // Delete tiles if provided
        if (isset($input['deleted_tiles']) && is_array($input['deleted_tiles']) && count($input['deleted_tiles']) > 0) {
            foreach ($input['deleted_tiles'] as $tileToDelete) {
                $q = isset($tileToDelete['q']) ? (int) $tileToDelete['q'] : null;
                $r = isset($tileToDelete['r']) ? (int) $tileToDelete['r'] : null;
                
                if ($q !== null && $r !== null) {
                    $db->delete(
                        "DELETE FROM hex_tiles WHERE map_id = ? AND q = ? AND r = ?",
                        [$mapId, $q, $r]
                    );
                    $tilesDeleted++;
                }
            }
        }
        
        // Save tiles if provided
        if (isset($input['tiles']) && is_array($input['tiles']) && count($input['tiles']) > 0) {
            $tiles = $input['tiles'];
            
            if (count($tiles) > 1000) {
                throw new Exception('Maximum 1000 tiles per save operation');
            }
            
            foreach ($tiles as $tileData) {
                $q = isset($tileData['q']) ? (int) $tileData['q'] : null;
                $r = isset($tileData['r']) ? (int) $tileData['r'] : null;
                
                if ($q === null || $r === null) {
                    continue; // Skip invalid tiles
                }
                
                $terrainType = Security::sanitizeInput($tileData['terrain_type'] ?? 'plains');
                $terrainName = Security::sanitizeInput($tileData['terrain_name'] ?? '');
                $description = Security::sanitizeInput($tileData['description'] ?? '');
                $notes = Security::sanitizeInput($tileData['notes'] ?? '');
                $imageUrl = Security::sanitizeInput($tileData['image_url'] ?? '');
                $elevation = isset($tileData['elevation']) ? (int) $tileData['elevation'] : 0;
                $isPassable = isset($tileData['is_passable']) ? (bool) $tileData['is_passable'] : true;
                $movementCost = isset($tileData['movement_cost']) ? (int) $tileData['movement_cost'] : 1;
                
                // Normalize borders: convert to object, then to JSON string or null
                $borders = null;
                if (isset($tileData['borders']) && $tileData['borders'] !== null) {
                    $bordersObj = null;
                    
                    // Convert to object/array if needed
                    if (is_string($tileData['borders'])) {
                        $decoded = json_decode($tileData['borders'], true);
                        if (json_last_error() === JSON_ERROR_NONE) {
                            $bordersObj = $decoded;
                        } else {
                            throw new Exception("Invalid borders JSON for tile ({$q}, {$r}): " . json_last_error_msg());
                        }
                    } elseif (is_array($tileData['borders']) || is_object($tileData['borders'])) {
                        $bordersObj = (array) $tileData['borders'];
                    }
                    
                    // Only encode if object has content (empty objects become null)
                    if ($bordersObj !== null && count($bordersObj) > 0) {
                        $encoded = json_encode($bordersObj, JSON_UNESCAPED_UNICODE);
                        if ($encoded === false) {
                            throw new Exception("Failed to encode borders JSON for tile ({$q}, {$r}): " . json_last_error_msg());
                        }
                        $borders = $encoded;
                    }
                }
                
                // Normalize roads: convert to object, then to JSON string or null
                $roads = null;
                if (isset($tileData['roads']) && $tileData['roads'] !== null) {
                    $roadsObj = null;
                    
                    // Convert to object/array if needed
                    if (is_string($tileData['roads'])) {
                        $decoded = json_decode($tileData['roads'], true);
                        if (json_last_error() === JSON_ERROR_NONE) {
                            $roadsObj = $decoded;
                        } else {
                            throw new Exception("Invalid roads JSON for tile ({$q}, {$r}): " . json_last_error_msg());
                        }
                    } elseif (is_array($tileData['roads']) || is_object($tileData['roads'])) {
                        $roadsObj = (array) $tileData['roads'];
                    }
                    
                    // Only encode if object has content (empty objects become null)
                    if ($roadsObj !== null && count($roadsObj) > 0) {
                        $encoded = json_encode($roadsObj, JSON_UNESCAPED_UNICODE);
                        if ($encoded === false) {
                            throw new Exception("Failed to encode roads JSON for tile ({$q}, {$r}): " . json_last_error_msg());
                        }
                        $roads = $encoded;
                    }
                }
                
                // Normalize paths: convert to object, then to JSON string or null
                $paths = null;
                if (isset($tileData['paths']) && $tileData['paths'] !== null) {
                    $pathsObj = null;
                    
                    // Convert to object/array if needed
                    if (is_string($tileData['paths'])) {
                        $decoded = json_decode($tileData['paths'], true);
                        if (json_last_error() === JSON_ERROR_NONE) {
                            $pathsObj = $decoded;
                        } else {
                            throw new Exception("Invalid paths JSON for tile ({$q}, {$r}): " . json_last_error_msg());
                        }
                    } elseif (is_array($tileData['paths']) || is_object($tileData['paths'])) {
                        $pathsObj = (array) $tileData['paths'];
                    }
                    
                    // Only encode if object has content (empty objects become null)
                    if ($pathsObj !== null && count($pathsObj) > 0) {
                        $encoded = json_encode($pathsObj, JSON_UNESCAPED_UNICODE);
                        if ($encoded === false) {
                            throw new Exception("Failed to encode paths JSON for tile ({$q}, {$r}): " . json_last_error_msg());
                        }
                        $paths = $encoded;
                    }
                }
                
                // Normalize rivers: convert to object, then to JSON string or null
                $rivers = null;
                if (isset($tileData['rivers']) && $tileData['rivers'] !== null) {
                    $riversObj = null;
                    
                    // Convert to object/array if needed
                    if (is_string($tileData['rivers'])) {
                        $decoded = json_decode($tileData['rivers'], true);
                        if (json_last_error() === JSON_ERROR_NONE) {
                            $riversObj = $decoded;
                        } else {
                            error_log("[HEX MAP SAVE] ERROR: Invalid rivers JSON for tile ({$q}, {$r}): " . json_last_error_msg() . " - Raw data: " . $tileData['rivers']);
                            throw new Exception("Invalid rivers JSON for tile ({$q}, {$r}): " . json_last_error_msg());
                        }
                    } elseif (is_array($tileData['rivers']) || is_object($tileData['rivers'])) {
                        $riversObj = (array) $tileData['rivers'];
                    }
                    
                    // Debug: Log what we received
                    if ($riversObj !== null) {
                        error_log("[HEX MAP SAVE] Tile ({$q}, {$r}) received rivers object with " . count($riversObj) . " keys: " . json_encode(array_keys($riversObj)));
                    } else {
                        error_log("[HEX MAP SAVE] Tile ({$q}, {$r}) rivers data is null after processing. Original data type: " . gettype($tileData['rivers']));
                    }
                    
                    // Only encode if object has content (empty objects become null)
                    if ($riversObj !== null && count($riversObj) > 0) {
                        $encoded = json_encode($riversObj, JSON_UNESCAPED_UNICODE);
                        if ($encoded === false) {
                            throw new Exception("Failed to encode rivers JSON for tile ({$q}, {$r}): " . json_last_error_msg());
                        }
                        $rivers = $encoded;
                        error_log("[HEX MAP SAVE] Tile ({$q}, {$r}) has rivers data: " . $encoded);
                    } else {
                        error_log("[HEX MAP SAVE] Tile ({$q}, {$r}) rivers object is empty or null - not encoding");
                    }
                } else {
                    error_log("[HEX MAP SAVE] Tile ({$q}, {$r}) has no rivers data in tileData");
                }
                
                if ($movementCost < 1) {
                    $movementCost = 1;
                }
                
                // Check if tile exists
                $existingTile = $db->selectOne(
                    "SELECT tile_id FROM hex_tiles WHERE map_id = ? AND q = ? AND r = ?",
                    [$mapId, $q, $r]
                );
                
                if ($existingTile) {
                    // Update - check if paths column exists
                    $tileId = $existingTile['tile_id'];
                    try {
                        // Try with paths and rivers columns
                        $db->update(
                            "UPDATE hex_tiles SET
                                terrain_type = ?,
                                terrain_name = ?,
                                description = ?,
                                notes = ?,
                                image_url = ?,
                                elevation = ?,
                                is_passable = ?,
                                movement_cost = ?,
                                borders = ?,
                                roads = ?,
                                paths = ?,
                                rivers = ?,
                                updated_at = NOW()
                             WHERE tile_id = ?",
                            [
                                $terrainType,
                                $terrainName ?: null,
                                $description ?: null,
                                $notes ?: null,
                                $imageUrl ?: null,
                                $elevation,
                                $isPassable,
                                $movementCost,
                                $borders,
                                $roads,
                                $paths,
                                $rivers,
                                $tileId
                            ]
                        );
                    } catch (Exception $e) {
                        // If rivers column doesn't exist, try without it
                        if (strpos($e->getMessage(), 'rivers') !== false || strpos($e->getMessage(), 'Unknown column') !== false) {
                            error_log("[HEX MAP SAVE] WARNING: rivers column does not exist for tile ({$q}, {$r}). Rivers data will not be saved. Error: " . $e->getMessage());
                            error_log("[HEX MAP SAVE] Rivers data that was lost: " . ($rivers ?: 'null'));
                            try {
                                // Try with paths but without rivers
                                $db->update(
                                    "UPDATE hex_tiles SET
                                        terrain_type = ?,
                                        terrain_name = ?,
                                        description = ?,
                                        notes = ?,
                                        image_url = ?,
                                        elevation = ?,
                                        is_passable = ?,
                                        movement_cost = ?,
                                        borders = ?,
                                        roads = ?,
                                        paths = ?,
                                        updated_at = NOW()
                                     WHERE tile_id = ?",
                                    [
                                        $terrainType,
                                        $terrainName ?: null,
                                        $description ?: null,
                                        $notes ?: null,
                                        $imageUrl ?: null,
                                        $elevation,
                                        $isPassable,
                                        $movementCost,
                                        $borders,
                                        $roads,
                                        $paths,
                                        $tileId
                                    ]
                                );
                            } catch (Exception $e2) {
                                // If paths column also doesn't exist, update without paths or rivers
                                if (strpos($e2->getMessage(), 'paths') !== false || strpos($e2->getMessage(), 'Unknown column') !== false) {
                                    $db->update(
                                        "UPDATE hex_tiles SET
                                            terrain_type = ?,
                                            terrain_name = ?,
                                            description = ?,
                                            notes = ?,
                                            image_url = ?,
                                            elevation = ?,
                                            is_passable = ?,
                                            movement_cost = ?,
                                            borders = ?,
                                            roads = ?,
                                            updated_at = NOW()
                                         WHERE tile_id = ?",
                                        [
                                            $terrainType,
                                            $terrainName ?: null,
                                            $description ?: null,
                                            $notes ?: null,
                                            $imageUrl ?: null,
                                            $elevation,
                                            $isPassable,
                                            $movementCost,
                                            $borders,
                                            $roads,
                                            $tileId
                                        ]
                                    );
                                } else {
                                    throw $e2;
                                }
                            }
                        } else {
                            throw $e; // Re-throw if it's a different error
                        }
                    }
                    $tilesUpdated++;
                } else {
                    // Create - check if paths and rivers columns exist
                    try {
                        // Try with paths and rivers columns
                        $db->insert(
                            "INSERT INTO hex_tiles (
                                map_id, q, r, terrain_type, terrain_name, description, notes,
                                image_url, elevation, is_passable, movement_cost, borders, roads, paths, rivers,
                                created_at, updated_at
                            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())",
                            [
                                $mapId,
                                $q,
                                $r,
                                $terrainType,
                                $terrainName ?: null,
                                $description ?: null,
                                $notes ?: null,
                                $imageUrl ?: null,
                                $elevation,
                                $isPassable,
                                $movementCost,
                                $borders,
                                $roads,
                                $paths,
                                $rivers
                            ]
                        );
                    } catch (Exception $e) {
                        // If rivers column doesn't exist, try without it
                        if (strpos($e->getMessage(), 'rivers') !== false || strpos($e->getMessage(), 'Unknown column') !== false) {
                            error_log("[HEX MAP SAVE] WARNING: rivers column does not exist for new tile ({$q}, {$r}). Rivers data will not be saved. Error: " . $e->getMessage());
                            error_log("[HEX MAP SAVE] Rivers data that was lost: " . ($rivers ?: 'null'));
                            try {
                                // Try with paths but without rivers
                                $db->insert(
                                    "INSERT INTO hex_tiles (
                                        map_id, q, r, terrain_type, terrain_name, description, notes,
                                        image_url, elevation, is_passable, movement_cost, borders, roads, paths,
                                        created_at, updated_at
                                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())",
                                    [
                                        $mapId,
                                        $q,
                                        $r,
                                        $terrainType,
                                        $terrainName ?: null,
                                        $description ?: null,
                                        $notes ?: null,
                                        $imageUrl ?: null,
                                        $elevation,
                                        $isPassable,
                                        $movementCost,
                                        $borders,
                                        $roads,
                                        $paths
                                    ]
                                );
                            } catch (Exception $e2) {
                                // If paths column also doesn't exist, insert without paths or rivers
                                if (strpos($e2->getMessage(), 'paths') !== false || strpos($e2->getMessage(), 'Unknown column') !== false) {
                                    $db->insert(
                                        "INSERT INTO hex_tiles (
                                            map_id, q, r, terrain_type, terrain_name, description, notes,
                                            image_url, elevation, is_passable, movement_cost, borders, roads,
                                            created_at, updated_at
                                        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())",
                                        [
                                            $mapId,
                                            $q,
                                            $r,
                                            $terrainType,
                                            $terrainName ?: null,
                                            $description ?: null,
                                            $notes ?: null,
                                            $imageUrl ?: null,
                                            $elevation,
                                            $isPassable,
                                            $movementCost,
                                            $borders,
                                            $roads
                                        ]
                                    );
                                } else {
                                    throw $e2;
                                }
                            }
                        } else {
                            throw $e; // Re-throw if it's a different error
                        }
                    }
                    $tilesCreated++;
                }
            }
        }
        
        // Commit transaction
        $db->commit();
        
        // Check if rivers column exists (for warning message)
        $riversColumnExists = false;
        $riversDataWasLost = false;
        try {
            $columnCheck = $db->selectOne(
                "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS 
                 WHERE TABLE_SCHEMA = DATABASE() 
                 AND TABLE_NAME = 'hex_tiles' 
                 AND COLUMN_NAME = 'rivers'"
            );
            $riversColumnExists = ($columnCheck !== null);
            
            // Check if any tiles had rivers data that couldn't be saved
            if (!$riversColumnExists && isset($input['tiles']) && is_array($input['tiles'])) {
                foreach ($input['tiles'] as $tileData) {
                    if (isset($tileData['rivers']) && $tileData['rivers'] !== null) {
                        $riversObj = null;
                        if (is_string($tileData['rivers'])) {
                            $decoded = json_decode($tileData['rivers'], true);
                            if (json_last_error() === JSON_ERROR_NONE) {
                                $riversObj = $decoded;
                            }
                        } elseif (is_array($tileData['rivers']) || is_object($tileData['rivers'])) {
                            $riversObj = (array) $tileData['rivers'];
                        }
                        if ($riversObj !== null && count($riversObj) > 0) {
                            $riversDataWasLost = true;
                            break;
                        }
                    }
                }
            }
        } catch (Exception $e) {
            // Ignore check errors
        }
        
        // Get updated map
        // Try to include scale and game_time, but handle gracefully if columns don't exist yet
        try {
            $updatedMap = $db->selectOne(
                "SELECT map_id, map_name, map_description, created_by_user_id, session_id,
                        width_hexes, height_hexes, hex_size_pixels, background_image_url,
                        game_time, scale, is_active, created_at, updated_at
                 FROM hex_maps
                 WHERE map_id = ?",
                [$mapId]
            );
        } catch (Exception $e) {
            // If scale or game_time columns don't exist yet, try without them
            if (strpos($e->getMessage(), 'scale') !== false || strpos($e->getMessage(), 'game_time') !== false || strpos($e->getMessage(), 'Unknown column') !== false) {
                try {
                    $updatedMap = $db->selectOne(
                        "SELECT map_id, map_name, map_description, created_by_user_id, session_id,
                                width_hexes, height_hexes, hex_size_pixels, background_image_url,
                                game_time, is_active, created_at, updated_at
                         FROM hex_maps
                         WHERE map_id = ?",
                        [$mapId]
                    );
                    if (strpos($e->getMessage(), 'scale') !== false) {
                        $updatedMap['scale'] = null;
                    }
                } catch (Exception $e2) {
                    // If both don't exist, select without both
                    if (strpos($e2->getMessage(), 'game_time') !== false || strpos($e2->getMessage(), 'Unknown column') !== false) {
                        $updatedMap = $db->selectOne(
                            "SELECT map_id, map_name, map_description, created_by_user_id, session_id,
                                    width_hexes, height_hexes, hex_size_pixels, background_image_url,
                                    is_active, created_at, updated_at
                             FROM hex_maps
                             WHERE map_id = ?",
                            [$mapId]
                        );
                        $updatedMap['game_time'] = null;
                        $updatedMap['scale'] = null;
                    } else {
                        throw $e2;
                    }
                }
            } else {
                throw $e;
            }
        }
        
        Security::logSecurityEvent('hex_map_saved', [
            'map_id' => $mapId,
            'tiles_saved' => isset($input['tiles']) ? count($input['tiles']) : 0,
            'tiles_deleted' => $tilesDeleted,
            'user_id' => $userId
        ]);
        
        Security::sendSuccessResponse([
            'map' => [
                'map_id' => (int) $updatedMap['map_id'],
                'map_name' => $updatedMap['map_name'],
                'map_description' => $updatedMap['map_description'],
                'created_by_user_id' => (int) $updatedMap['created_by_user_id'],
                'session_id' => $updatedMap['session_id'] ? (int) $updatedMap['session_id'] : null,
                'width_hexes' => (int) $updatedMap['width_hexes'],
                'height_hexes' => (int) $updatedMap['height_hexes'],
                'hex_size_pixels' => (int) $updatedMap['hex_size_pixels'],
                'background_image_url' => $updatedMap['background_image_url'],
                'game_time' => isset($updatedMap['game_time']) ? $updatedMap['game_time'] : null,
                'scale' => isset($updatedMap['scale']) && $updatedMap['scale'] !== null ? (float) $updatedMap['scale'] : null,
                'is_active' => (bool) $updatedMap['is_active'],
                'created_at' => $updatedMap['created_at'],
                'updated_at' => $updatedMap['updated_at']
            ],
            'tiles_saved' => isset($input['tiles']) ? count($input['tiles']) : 0,
            'tiles_created' => $tilesCreated,
            'tiles_updated' => $tilesUpdated,
            'tiles_deleted' => $tilesDeleted,
            'rivers_column_exists' => $riversColumnExists,
            'rivers_data_lost' => $riversDataWasLost
        ], $riversDataWasLost 
            ? 'Map saved successfully, but rivers data was not saved because the rivers column does not exist in the database. Please run migration 018_hex_map_rivers.sql'
            : 'Map saved successfully');
        
    } catch (Exception $e) {
        // Rollback transaction if it was started
        try {
            if ($db->inTransaction()) {
                $db->rollback();
            }
        } catch (Exception $rollbackError) {
            error_log('Failed to rollback transaction: ' . $rollbackError->getMessage());
        }
        throw $e;
    }
    
} catch (Exception $e) {
    error_log('Hex map save error: ' . $e->getMessage());
    error_log('Hex map save trace: ' . $e->getTraceAsString());
    Security::sendErrorResponse('An error occurred while saving the hex map: ' . $e->getMessage(), 500);
}
?>

