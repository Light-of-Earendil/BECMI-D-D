<?php
/**
 * BECMI D&D Character Manager - Save Hex Map Endpoint
 * 
 * Saves both map metadata and all tiles in a single request.
 * This avoids session issues that occur when making multiple sequential requests.
 * 
 * **Request:** POST
 * 
 * **Body Parameters:**
 * - `map_id` (int, required) - Map ID to save
 * - `map_name` (string, optional) - Map name (3-100 characters)
 * - `map_description` (string, optional) - Map description
 * - `width_hexes` (int, optional) - Map width in hexes (1-200)
 * - `height_hexes` (int, optional) - Map height in hexes (1-200)
 * - `hex_size_pixels` (int, optional) - Hex size in pixels (10-200)
 * - `tiles` (array, optional) - Array of tile objects to save
 * - `deleted_tiles` (array, optional) - Array of {q, r} objects for tiles to delete
 * 
 * **Response:**
 * ```json
 * {
 *   "status": "success",
 *   "message": "Map saved successfully",
 *   "data": {
 *     "map": {...},
 *     "tiles_saved": int,
 *     "tiles_created": int,
 *     "tiles_updated": int,
 *     "tiles_deleted": int
 *   }
 * }
 * ```
 * 
 * **Permissions:**
 * - Map creator: Can save map
 * - Session DM: Can save map
 * - Others: 403 Forbidden
 * 
 * **Called From:**
 * - `HexMapEditorModule.saveMap()` - Saves entire map in one request
 * 
 * @package api/hex-maps
 * @api POST /api/hex-maps/save.php
 * @since 1.0.0
 */

// Start output buffering BEFORE any includes to catch any output
if (!ob_get_level()) {
    ob_start();
}

require_once '../../app/core/database.php';
require_once '../../app/core/security.php';

// Clear any output that might have been generated by includes
if (ob_get_level() && ob_get_length() > 0) {
    ob_clean();
}

// Initialize security
Security::init();

// Set content type
header('Content-Type: application/json');

try {
    // Only allow POST requests
    if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
        Security::sendErrorResponse('Method not allowed', 405);
    }
    
    // Get JSON input FIRST (before auth check)
    $input = Security::validateJSONInput();
    
    // Validate required fields
    $mapId = isset($input['map_id']) ? (int) $input['map_id'] : 0;
    
    if ($mapId <= 0) {
        Security::sendValidationErrorResponse(['map_id' => 'Valid map ID is required']);
    }
    
    // Get user ID - try session first, fallback to request if session fails
    $userId = null;
    
    // Try to get from session
    if (Security::isAuthenticated()) {
        $userId = Security::getCurrentUserId();
    }
    
    // If session failed, try to get from request
    if (!$userId || $userId <= 0) {
        if (isset($input['user_id']) && is_numeric($input['user_id'])) {
            $userId = (int) $input['user_id'];
            
            // Validate user exists in database
            $db = getDB();
            $user = $db->selectOne("SELECT user_id FROM users WHERE user_id = ?", [$userId]);
            if (!$user) {
                Security::sendErrorResponse('Invalid user ID', 401);
            }
        } else {
            Security::sendErrorResponse('Authentication required', 401);
        }
    }
    
    // Check CSRF token (only if session works)
    if (Security::isAuthenticated() && !Security::checkCSRFToken()) {
        Security::sendErrorResponse('Invalid CSRF token', 403);
    }
    
    // Get database connection (if not already got)
    if (!isset($db)) {
        $db = getDB();
    }
    
    // Get map and verify permissions
    $map = $db->selectOne(
        "SELECT hm.map_id, hm.created_by_user_id, hm.session_id, gs.dm_user_id as session_dm_user_id
         FROM hex_maps hm
         LEFT JOIN game_sessions gs ON hm.session_id = gs.session_id
         WHERE hm.map_id = ?",
        [$mapId]
    );
    
    if (!$map) {
        Security::sendErrorResponse('Hex map not found', 404);
    }
    
    // Check permissions: creator or session DM can save
    $canSave = false;
    if ($map['created_by_user_id'] == $userId) {
        $canSave = true;
    } elseif ($map['session_id'] && $map['session_dm_user_id'] == $userId) {
        $canSave = true;
    }
    
    if (!$canSave) {
        Security::sendErrorResponse('You do not have permission to save this hex map', 403);
    }
    
    // Begin transaction for atomic save
    $db->beginTransaction();
    
    try {
        $tilesCreated = 0;
        $tilesUpdated = 0;
        $tilesDeleted = 0;
        
        // Update map metadata if provided
        if (isset($input['map_name']) || isset($input['map_description']) || 
            isset($input['width_hexes']) || isset($input['height_hexes']) || 
            isset($input['hex_size_pixels'])) {
            
            $updateFields = [];
            $updateParams = [];
            
            if (isset($input['map_name'])) {
                $mapName = Security::sanitizeInput($input['map_name']);
                if (strlen($mapName) < 3 || strlen($mapName) > 100) {
                    throw new Exception('Map name must be between 3 and 100 characters');
                }
                $updateFields[] = "map_name = ?";
                $updateParams[] = $mapName;
            }
            
            if (isset($input['map_description'])) {
                $updateFields[] = "map_description = ?";
                $updateParams[] = Security::sanitizeInput($input['map_description']) ?: null;
            }
            
            if (isset($input['width_hexes'])) {
                $widthHexes = (int) $input['width_hexes'];
                if ($widthHexes < 1 || $widthHexes > 200) {
                    throw new Exception('Width must be between 1 and 200 hexes');
                }
                $updateFields[] = "width_hexes = ?";
                $updateParams[] = $widthHexes;
            }
            
            if (isset($input['height_hexes'])) {
                $heightHexes = (int) $input['height_hexes'];
                if ($heightHexes < 1 || $heightHexes > 200) {
                    throw new Exception('Height must be between 1 and 200 hexes');
                }
                $updateFields[] = "height_hexes = ?";
                $updateParams[] = $heightHexes;
            }
            
            if (isset($input['hex_size_pixels'])) {
                $hexSizePixels = (int) $input['hex_size_pixels'];
                if ($hexSizePixels < 10 || $hexSizePixels > 200) {
                    throw new Exception('Hex size must be between 10 and 200 pixels');
                }
                $updateFields[] = "hex_size_pixels = ?";
                $updateParams[] = $hexSizePixels;
            }
            
            if (!empty($updateFields)) {
                $updateFields[] = "updated_at = NOW()";
                $updateParams[] = $mapId;
                
                $sql = "UPDATE hex_maps SET " . implode(", ", $updateFields) . " WHERE map_id = ?";
                $db->update($sql, $updateParams);
            }
        }
        
        // Delete tiles if provided
        if (isset($input['deleted_tiles']) && is_array($input['deleted_tiles']) && count($input['deleted_tiles']) > 0) {
            foreach ($input['deleted_tiles'] as $tileToDelete) {
                $q = isset($tileToDelete['q']) ? (int) $tileToDelete['q'] : null;
                $r = isset($tileToDelete['r']) ? (int) $tileToDelete['r'] : null;
                
                if ($q !== null && $r !== null) {
                    $db->delete(
                        "DELETE FROM hex_tiles WHERE map_id = ? AND q = ? AND r = ?",
                        [$mapId, $q, $r]
                    );
                    $tilesDeleted++;
                }
            }
        }
        
        // Save tiles if provided
        if (isset($input['tiles']) && is_array($input['tiles']) && count($input['tiles']) > 0) {
            $tiles = $input['tiles'];
            
            if (count($tiles) > 1000) {
                throw new Exception('Maximum 1000 tiles per save operation');
            }
            
            foreach ($tiles as $tileData) {
                $q = isset($tileData['q']) ? (int) $tileData['q'] : null;
                $r = isset($tileData['r']) ? (int) $tileData['r'] : null;
                
                if ($q === null || $r === null) {
                    continue; // Skip invalid tiles
                }
                
                $terrainType = Security::sanitizeInput($tileData['terrain_type'] ?? 'plains');
                $terrainName = Security::sanitizeInput($tileData['terrain_name'] ?? '');
                $description = Security::sanitizeInput($tileData['description'] ?? '');
                $notes = Security::sanitizeInput($tileData['notes'] ?? '');
                $imageUrl = Security::sanitizeInput($tileData['image_url'] ?? '');
                $elevation = isset($tileData['elevation']) ? (int) $tileData['elevation'] : 0;
                $isPassable = isset($tileData['is_passable']) ? (bool) $tileData['is_passable'] : true;
                $movementCost = isset($tileData['movement_cost']) ? (int) $tileData['movement_cost'] : 1;
                
                // Normalize borders: convert to object, then to JSON string or null
                $borders = null;
                if (isset($tileData['borders']) && $tileData['borders'] !== null) {
                    $bordersObj = null;
                    
                    // Convert to object/array if needed
                    if (is_string($tileData['borders'])) {
                        $decoded = json_decode($tileData['borders'], true);
                        if (json_last_error() === JSON_ERROR_NONE) {
                            $bordersObj = $decoded;
                        } else {
                            throw new Exception("Invalid borders JSON for tile ({$q}, {$r}): " . json_last_error_msg());
                        }
                    } elseif (is_array($tileData['borders']) || is_object($tileData['borders'])) {
                        $bordersObj = (array) $tileData['borders'];
                    }
                    
                    // Only encode if object has content (empty objects become null)
                    if ($bordersObj !== null && count($bordersObj) > 0) {
                        $encoded = json_encode($bordersObj, JSON_UNESCAPED_UNICODE);
                        if ($encoded === false) {
                            throw new Exception("Failed to encode borders JSON for tile ({$q}, {$r}): " . json_last_error_msg());
                        }
                        $borders = $encoded;
                    }
                }
                
                // Normalize roads: convert to object, then to JSON string or null
                $roads = null;
                if (isset($tileData['roads']) && $tileData['roads'] !== null) {
                    $roadsObj = null;
                    
                    // Convert to object/array if needed
                    if (is_string($tileData['roads'])) {
                        $decoded = json_decode($tileData['roads'], true);
                        if (json_last_error() === JSON_ERROR_NONE) {
                            $roadsObj = $decoded;
                        } else {
                            throw new Exception("Invalid roads JSON for tile ({$q}, {$r}): " . json_last_error_msg());
                        }
                    } elseif (is_array($tileData['roads']) || is_object($tileData['roads'])) {
                        $roadsObj = (array) $tileData['roads'];
                    }
                    
                    // Only encode if object has content (empty objects become null)
                    if ($roadsObj !== null && count($roadsObj) > 0) {
                        $encoded = json_encode($roadsObj, JSON_UNESCAPED_UNICODE);
                        if ($encoded === false) {
                            throw new Exception("Failed to encode roads JSON for tile ({$q}, {$r}): " . json_last_error_msg());
                        }
                        $roads = $encoded;
                    }
                }
                
                // Normalize paths: convert to object, then to JSON string or null
                $paths = null;
                if (isset($tileData['paths']) && $tileData['paths'] !== null) {
                    $pathsObj = null;
                    
                    // Convert to object/array if needed
                    if (is_string($tileData['paths'])) {
                        $decoded = json_decode($tileData['paths'], true);
                        if (json_last_error() === JSON_ERROR_NONE) {
                            $pathsObj = $decoded;
                        } else {
                            throw new Exception("Invalid paths JSON for tile ({$q}, {$r}): " . json_last_error_msg());
                        }
                    } elseif (is_array($tileData['paths']) || is_object($tileData['paths'])) {
                        $pathsObj = (array) $tileData['paths'];
                    }
                    
                    // Only encode if object has content (empty objects become null)
                    if ($pathsObj !== null && count($pathsObj) > 0) {
                        $encoded = json_encode($pathsObj, JSON_UNESCAPED_UNICODE);
                        if ($encoded === false) {
                            throw new Exception("Failed to encode paths JSON for tile ({$q}, {$r}): " . json_last_error_msg());
                        }
                        $paths = $encoded;
                    }
                }
                
                if ($movementCost < 1) {
                    $movementCost = 1;
                }
                
                // Check if tile exists
                $existingTile = $db->selectOne(
                    "SELECT tile_id FROM hex_tiles WHERE map_id = ? AND q = ? AND r = ?",
                    [$mapId, $q, $r]
                );
                
                if ($existingTile) {
                    // Update - check if paths column exists
                    $tileId = $existingTile['tile_id'];
                    try {
                        // Try with paths column
                        $db->update(
                            "UPDATE hex_tiles SET
                                terrain_type = ?,
                                terrain_name = ?,
                                description = ?,
                                notes = ?,
                                image_url = ?,
                                elevation = ?,
                                is_passable = ?,
                                movement_cost = ?,
                                borders = ?,
                                roads = ?,
                                paths = ?,
                                updated_at = NOW()
                             WHERE tile_id = ?",
                            [
                                $terrainType,
                                $terrainName ?: null,
                                $description ?: null,
                                $notes ?: null,
                                $imageUrl ?: null,
                                $elevation,
                                $isPassable,
                                $movementCost,
                                $borders,
                                $roads,
                                $paths,
                                $tileId
                            ]
                        );
                    } catch (Exception $e) {
                        // If paths column doesn't exist, update without it
                        if (strpos($e->getMessage(), 'paths') !== false || strpos($e->getMessage(), 'Unknown column') !== false) {
                            $db->update(
                                "UPDATE hex_tiles SET
                                    terrain_type = ?,
                                    terrain_name = ?,
                                    description = ?,
                                    notes = ?,
                                    image_url = ?,
                                    elevation = ?,
                                    is_passable = ?,
                                    movement_cost = ?,
                                    borders = ?,
                                    roads = ?,
                                    updated_at = NOW()
                                 WHERE tile_id = ?",
                                [
                                    $terrainType,
                                    $terrainName ?: null,
                                    $description ?: null,
                                    $notes ?: null,
                                    $imageUrl ?: null,
                                    $elevation,
                                    $isPassable,
                                    $movementCost,
                                    $borders,
                                    $roads,
                                    $tileId
                                ]
                            );
                        } else {
                            throw $e; // Re-throw if it's a different error
                        }
                    }
                    $tilesUpdated++;
                } else {
                    // Create - check if paths column exists
                    try {
                        // Try with paths column
                        $db->insert(
                            "INSERT INTO hex_tiles (
                                map_id, q, r, terrain_type, terrain_name, description, notes,
                                image_url, elevation, is_passable, movement_cost, borders, roads, paths,
                                created_at, updated_at
                            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())",
                            [
                                $mapId,
                                $q,
                                $r,
                                $terrainType,
                                $terrainName ?: null,
                                $description ?: null,
                                $notes ?: null,
                                $imageUrl ?: null,
                                $elevation,
                                $isPassable,
                                $movementCost,
                                $borders,
                                $roads,
                                $paths
                            ]
                        );
                    } catch (Exception $e) {
                        // If paths column doesn't exist, insert without it
                        if (strpos($e->getMessage(), 'paths') !== false || strpos($e->getMessage(), 'Unknown column') !== false) {
                            $db->insert(
                                "INSERT INTO hex_tiles (
                                    map_id, q, r, terrain_type, terrain_name, description, notes,
                                    image_url, elevation, is_passable, movement_cost, borders, roads,
                                    created_at, updated_at
                                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())",
                                [
                                    $mapId,
                                    $q,
                                    $r,
                                    $terrainType,
                                    $terrainName ?: null,
                                    $description ?: null,
                                    $notes ?: null,
                                    $imageUrl ?: null,
                                    $elevation,
                                    $isPassable,
                                    $movementCost,
                                    $borders,
                                    $roads
                                ]
                            );
                        } else {
                            throw $e; // Re-throw if it's a different error
                        }
                    }
                    $tilesCreated++;
                }
            }
        }
        
        // Commit transaction
        $db->commit();
        
        // Get updated map
        $updatedMap = $db->selectOne(
            "SELECT map_id, map_name, map_description, created_by_user_id, session_id,
                    width_hexes, height_hexes, hex_size_pixels, background_image_url,
                    is_active, created_at, updated_at
             FROM hex_maps
             WHERE map_id = ?",
            [$mapId]
        );
        
        Security::logSecurityEvent('hex_map_saved', [
            'map_id' => $mapId,
            'tiles_saved' => isset($input['tiles']) ? count($input['tiles']) : 0,
            'tiles_deleted' => $tilesDeleted,
            'user_id' => $userId
        ]);
        
        Security::sendSuccessResponse([
            'map' => [
                'map_id' => (int) $updatedMap['map_id'],
                'map_name' => $updatedMap['map_name'],
                'map_description' => $updatedMap['map_description'],
                'created_by_user_id' => (int) $updatedMap['created_by_user_id'],
                'session_id' => $updatedMap['session_id'] ? (int) $updatedMap['session_id'] : null,
                'width_hexes' => (int) $updatedMap['width_hexes'],
                'height_hexes' => (int) $updatedMap['height_hexes'],
                'hex_size_pixels' => (int) $updatedMap['hex_size_pixels'],
                'background_image_url' => $updatedMap['background_image_url'],
                'is_active' => (bool) $updatedMap['is_active'],
                'created_at' => $updatedMap['created_at'],
                'updated_at' => $updatedMap['updated_at']
            ],
            'tiles_saved' => isset($input['tiles']) ? count($input['tiles']) : 0,
            'tiles_created' => $tilesCreated,
            'tiles_updated' => $tilesUpdated,
            'tiles_deleted' => $tilesDeleted
        ], 'Map saved successfully');
        
    } catch (Exception $e) {
        // Rollback transaction if it was started
        try {
            if ($db->inTransaction()) {
                $db->rollback();
            }
        } catch (Exception $rollbackError) {
            error_log('Failed to rollback transaction: ' . $rollbackError->getMessage());
        }
        throw $e;
    }
    
} catch (Exception $e) {
    error_log('Hex map save error: ' . $e->getMessage());
    error_log('Hex map save trace: ' . $e->getTraceAsString());
    Security::sendErrorResponse('An error occurred while saving the hex map: ' . $e->getMessage(), 500);
}
?>

